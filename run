#!/usr/bin/env bash
#
# usage: ./run.sh command [argument ...]
#
# Commands used during development / CI.
# Also, executable documentation for project dev practices.
#
# See https://death.andgravity.com/run-sh
# for an explanation of how it works and why it's useful.

################################################################################
# Core Development Commands

function build {
  # Build the firmware project.
  # Usage: build [--release]
  cargo build $@
  # Create .elf copy for tools that expect the extension
  if [ -f target/thumbv6m-none-eabi/release/halpi2-rs-firmware ]; then
    cp target/thumbv6m-none-eabi/release/halpi2-rs-firmware target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf
  fi
  if [ -f target/thumbv6m-none-eabi/debug/halpi2-rs-firmware ]; then
    cp target/thumbv6m-none-eabi/debug/halpi2-rs-firmware target/thumbv6m-none-eabi/debug/halpi2-rs-firmware.elf
  fi
}

function build:bootloader {
  # Build the bootloader.
  # Usage: build:bootloader [--release]
  cargo build -p bootloader --release $@
}

function clean {
  # Remove all build artifacts and temporary files.
  cargo clean $@
  # Remove any .elf copies that might be left behind
  rm -f target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf
  rm -f target/thumbv6m-none-eabi/debug/halpi2-rs-firmware.elf
  # Remove artifacts directories
  rm -rf firmware/artifacts
  rm -rf artifacts
}

function check {
  # Run cargo check and clippy for code quality.
  cargo check --all-targets
  cargo clippy --all-targets -- -D warnings
}

################################################################################
# Hardware Interaction Commands

function flash {
  # Flash firmware, bootloader, or both to RP2040.
  # Usage: flash [firmware|bootloader|all]
  local target=${1:-firmware}
  
  case $target in
    firmware)
      cargo flash --chip RP2040
      ;;
    bootloader)
      cargo flash --chip RP2040 --release -p bootloader
      ;;
    all)
      build:bootloader
      build --release
      cargo flash --chip RP2040 --release -p bootloader
      cargo flash --chip RP2040
      ;;
    *)
      echo "Error: Invalid flash target '$target'. Use: firmware, bootloader, or all"
      exit 1
      ;;
  esac
}

function monitor {
  # Attach debugger/monitor to running firmware.
  probe-rs attach --chip RP2040 target/thumbv6m-none-eabi/debug/halpi2-rs-firmware.elf $@
}

function flash:monitor {
  # Flash firmware and then attach monitor (common development workflow).
  cargo flash --chip RP2040
  monitor $@
}

################################################################################
# Release/Artifact Commands

function release:version {
  # Get the current firmware version from Cargo.toml.
  VERSION=$(grep -m1 '^version = ' firmware/Cargo.toml | cut -d'"' -f2)
  echo "$VERSION"
}

function release:build {
  # Build all release artifacts (ELF, BIN, UF2).
  echo "üèóÔ∏è Building release artifacts..."
  
  # Build both bootloader and firmware
  build:bootloader
  build --release
  
  # Get versions
  BOOTLOADER_VERSION=$(cargo pkgid -p bootloader | sed 's/.*#//')
  FIRMWARE_VERSION=$(release:version)
  
  # Create artifacts directory
  mkdir -p artifacts
  
  # Copy ELF files
  cp target/thumbv6m-none-eabi/release/bootloader artifacts/halpi2-rs-bootloader_${BOOTLOADER_VERSION}.elf
  cp target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf artifacts/halpi2-rs-firmware_${FIRMWARE_VERSION}.elf
  
  # Convert to other formats
  release:artifacts
  
  echo "‚úì Release artifacts created in artifacts/ directory"
}

function release:artifacts {
  # Convert existing ELF files to BIN and UF2 formats.
  echo "üîÑ Converting artifacts..."
  
  if [ ! -d "artifacts" ]; then
    echo "Error: artifacts directory not found. Run 'release:build' first."
    exit 1
  fi
  
  # Convert each ELF to UF2 and BIN
  for elf in artifacts/*.elf; do
    if [ -f "$elf" ]; then
      base=$(basename "$elf" .elf)
      echo "Converting $base..."
      
      # Convert to UF2 (for bootsel mode flashing) using picotool
      picotool uf2 convert "$elf" "artifacts/${base}.uf2"
      
      # Convert to BIN (for some programming tools)
      if [[ "$base" == *"firmware"* ]]; then
        cargo objcopy --release -- -O binary "artifacts/${base}.bin"
      else
        cargo objcopy -p bootloader --release -- -O binary "artifacts/${base}.bin"
      fi
      
      echo "‚úì Created ${base}.uf2 and ${base}.bin"
    fi
  done
}

################################################################################
# Package Management Commands

function package:deb {
  # Build Debian package using native tools.
  dev:env
  echo "üèóÔ∏è Building Debian package..."
  
  export DEBEMAIL="info@hatlabs.fi"
  export DEBFULLNAME="Hat Labs CI"
  export FIRMWARE_VERSION=$(cat firmware/VERSION)
  DEB_VERSION=$(echo "$FIRMWARE_VERSION" | sed 's/-\([a-zA-Z]\)/~\1/g')

  envsubst < debian/install.in > debian/install

  # Create a new changelog entry
  dch --newversion "$DEB_VERSION" \
      --distribution stable \
      --force-distribution \
      "Automated release $FIRMWARE_VERSION. See GitHub for details."

  dpkg-buildpackage -us -uc -b
}

function package:deb:docker {
  # Build Debian package using Docker container.
  export DIR_NAME=$(basename "$PWD")
  docker compose -f docker/docker-compose.debtools.yml run --rm debtools ./run package:deb
}

function package:docker:build {
  # Build the Docker tools container.
  export DIR_NAME=$(basename "$PWD")
  docker compose -f docker/docker-compose.debtools.yml build debtools "$@"
}

################################################################################
# Testing/CI Commands

function test:prepare {
  # Copy firmware artifacts to test directory.
  build:bootloader
  build --release
  
  VERSION=$(release:version)
  BOOTLOADER_VERSION=$(cargo pkgid -p bootloader | sed 's/.*#//')
  
  cp target/thumbv6m-none-eabi/release/bootloader ../HALPI2-tests/tests/200_controller/files/halpi2-rs-bootloader_${BOOTLOADER_VERSION}.elf
  cp target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf ../HALPI2-tests/tests/200_controller/files/halpi2-rs-firmware_${VERSION}.elf
}

function ci:build {
  # Full CI build pipeline - builds everything needed for release.
  echo "üöÄ Running full CI build pipeline..."
  
  # Clean start
  clean
  
  # Build and check code quality
  check
  
  # Build all artifacts
  release:build
  
  # Build packages
  package:deb:docker
  
  echo "‚úÖ CI build pipeline completed successfully"
}

function ci:check {
  # Run CI verification checks without building artifacts.
  echo "üîç Running CI verification checks..."
  
  check
  build --release
  build:bootloader
  
  echo "‚úÖ CI checks passed"
}

################################################################################
# Development Utilities Commands

function dev:env {
  # Set up and display development environment.
  echo "üóùÔ∏è Setting environment from .env and .env.defaults"
  # Go through the files and export all variables not already present in
  # the environment. First file has precedence!
  if [ -f .env ]; then
    _export_unset .env
  else
    # Make sure a .env file exists, otherwise docker-compose will complain
    cp .env.defaults .env
  fi
  if [ -f .env.defaults ]; then
    _export_unset .env.defaults
  fi
}

function dev:clean:all {
  # Deep clean - remove all build artifacts, packages, and containers.
  echo "üßπ Performing deep clean..."
  
  # Clean cargo artifacts
  clean
  
  # Clean Debian packages
  rm -f ../*.deb ../*.buildinfo ../*.changes
  
  # Clean Docker containers and images
  export DIR_NAME=$(basename "$PWD")
  docker compose -f docker/docker-compose.debtools.yml down --rmi all --volumes || true
  
  echo "‚úÖ Deep clean completed"
}

function dev:version:bump {
  # Bump to a specific version using bump2version.
  # Usage: dev:version:bump <new_version>
  local new_version="${1:-}"
  
  if [ -z "$new_version" ]; then
    echo "Error: Version required. Usage: dev:version:bump <new_version>"
    echo "Current version: $(release:version)"
    echo "Example: ./run dev:version:bump 3.2.0"
    exit 1
  fi
  
  echo "üîñ Bumping version from $(release:version) to $new_version..."
  bump2version --new-version "$new_version" patch
  echo "‚úì Version bumped to $(release:version)"
}

function dev:version:dry-run {
  # Preview version change without applying.
  # Usage: dev:version:dry-run <new_version>
  local new_version="${1:-}"
  
  if [ -z "$new_version" ]; then
    echo "Error: Version required. Usage: dev:version:dry-run <new_version>"
    echo "Current version: $(release:version)"
    echo "Example: ./run dev:version:dry-run 3.2.0"
    exit 1
  fi
  
  echo "Current version: $(release:version)"
  echo "Preview of changes for version $new_version:"
  bump2version --new-version "$new_version" patch --dry-run --verbose
}

function dev:version:show {
  # Show current version (alias for release:version for consistency).
  release:version
}

################################################################################
# Project-specific commands end.

# First, set up the environment.
# (Check the notes at the end when changing this.)

set -o nounset
set -o pipefail
set -o errexit

# Enable this to echo commands as they are executed.
#set -o xtrace

# Change the current directory to the project root.
PROJECT_ROOT=${0%/*}
if [[ $0 != $PROJECT_ROOT && $PROJECT_ROOT != "" ]]; then
  cd "$PROJECT_ROOT"
fi
readonly PROJECT_ROOT=$(pwd)

# Store the absolute path to this script (useful for recursion).
readonly SCRIPT="$PROJECT_ROOT/$(basename "$0")"

################################################################################
# Meta-commands and utilities follow.

function help {
  # List all available commands organized by category.
  printf "%s <command> [args]\n\n" "${0}"
  
  echo "Core Development Commands:"
  echo "  build [--release]              Build firmware (debug by default)"
  echo "  build:bootloader [--release]   Build bootloader"
  echo "  clean                          Clean all build artifacts"
  echo "  check                          Run cargo check and clippy"
  echo ""
  
  echo "Hardware Interaction Commands:"
  echo "  flash [firmware|bootloader|all] Flash to device (default: firmware)"
  echo "  monitor                        Attach debugger/monitor"
  echo "  flash:monitor                  Flash then monitor"
  echo ""
  
  echo "Release/Artifact Commands:"
  echo "  release:build                  Build all release artifacts (elf, bin, uf2)"
  echo "  release:artifacts              Convert existing ELF to bin/uf2 formats"
  echo "  release:version                Get current firmware version"
  echo ""
  
  echo "Package Management Commands:"
  echo "  package:deb                    Build Debian package (native)"
  echo "  package:deb:docker             Build Debian package using Docker"
  echo "  package:docker:build           Build Docker tools image"
  echo ""
  
  echo "Testing/CI Commands:"
  echo "  test:prepare                   Copy artifacts to test directory"
  echo "  ci:build                       Full CI build pipeline"
  echo "  ci:check                       CI verification checks"
  echo ""
  
  echo "Development Utilities:"
  echo "  dev:env                        Show/check development environment"
  echo "  dev:clean:all                  Deep clean (cargo + artifacts + packages)"
  echo "  dev:version:bump <version>     Bump to specific version (e.g. 3.2.0)"
  echo "  dev:version:dry-run <version>  Preview version change without applying"
  echo "  dev:version:show               Show current version"
  echo ""
  
  printf "Extended help:\n  Each command has comments for general usage\n"
}

once_hash_array=()
function _once {
  # Run a command only once during the execution of this script, even if it's
  # called multiple times.
  #
  # Usage:
  #   _once <command> [argument ...]
  #
  # Example:
  #   _once echo "Hello"
  #   _once echo "Hello"  # won't be executed

  local command="$*"
  local hash=$(echo "$command" | shasum | cut -d' ' -f1)
  if [[ ! " ${once_hash_array[@]} " =~ " ${hash} " ]]; then
    once_hash_array+=("$hash")
    eval "$command"
  fi
}

function _export_unset {
  local file="$1"

  # Need to use a temp file to avoid a subshell
  local tmpfile=$(mktemp)
  grep -v '^#' $file >$tmpfile

  while read -r line; do
    if [[ ! "$line" =~ ^[[:space:]]*$ ]]; then
      varname=$(echo "$line" | cut -d= -f1)
      if [[ -z "${!varname:-}" ]]; then
        eval $line
        export $varname
      fi
    fi
  done <$tmpfile
  rm $tmpfile
}

# Dispatch to command. A simpler version would be just "$@" (with the quotes!).

TIMEFORMAT=$'\nTask completed in %3lR'
time "${@:-help}"

# Some dev notes for this script.
#
# The commands *require*:
#
# * The current working directory is the project root.
# * The shell options and globals are set as they are.
#
# Inspired by the following:
#  - https://death.andgravity.com/run-sh
#  - http://www.oilshell.org/blog/2020/02/good-parts-sketch.html
#  - https://www.youtube.com/watch?v=SdmYd5hJISM&t=7s