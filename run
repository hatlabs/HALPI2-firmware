#!/usr/bin/env bash
#
# usage: ./run.sh command [argument ...]
#
# Commands used during development / CI.
# Also, executable documentation for project dev practices.
#
# See https://death.andgravity.com/run-sh
# for an explanation of how it works and why it's useful.

################################################################################
# Core Development Commands

function build {
  #@ Build firmware (debug by default)
  #@ Usage: build [--release]
  #@ Category: Core Development
  cargo build $@
  # Create .elf copy for tools that expect the extension
  if [ -f target/thumbv6m-none-eabi/release/halpi2-rs-firmware ]; then
    cp target/thumbv6m-none-eabi/release/halpi2-rs-firmware target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf
  fi
  if [ -f target/thumbv6m-none-eabi/debug/halpi2-rs-firmware ]; then
    cp target/thumbv6m-none-eabi/debug/halpi2-rs-firmware target/thumbv6m-none-eabi/debug/halpi2-rs-firmware.elf
  fi
}

function build:bootloader {
  #@ Build the bootloader
  #@ Usage: build:bootloader [--release]
  #@ Category: Core Development
  cargo build -p bootloader --release $@
}

function clean {
  #@ Clean all build artifacts
  #@ Category: Core Development
  cargo clean $@
  # Remove any .elf copies that might be left behind
  rm -f target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf
  rm -f target/thumbv6m-none-eabi/debug/halpi2-rs-firmware.elf
  # Remove artifacts directories
  rm -rf firmware/artifacts
  rm -rf artifacts
}

function check {
  #@ Run cargo check and clippy
  #@ Category: Core Development
  cargo check --all-targets
  cargo clippy --all-targets -- -D warnings
}

################################################################################
# Hardware Interaction Commands

function flash {
  #@ Flash to device (default: firmware)
  #@ Usage: flash [firmware|bootloader|all]
  #@ Category: Hardware Interaction
  local target=${1:-firmware}

  case $target in
    firmware)
      cargo flash --chip RP2040
      ;;
    bootloader)
      cargo flash --chip RP2040 --release -p bootloader
      ;;
    all)
      build:bootloader
      build --release
      cargo flash --chip RP2040 --release -p bootloader
      cargo flash --chip RP2040
      ;;
    *)
      echo "Error: Invalid flash target '$target'. Use: firmware, bootloader, or all"
      exit 1
      ;;
  esac
}

function monitor {
  #@ Attach debugger/monitor
  #@ Category: Hardware Interaction
  probe-rs attach --chip RP2040 target/thumbv6m-none-eabi/debug/halpi2-rs-firmware.elf $@
}

function flash:monitor {
  #@ Flash then monitor (common workflow)
  #@ Category: Hardware Interaction
  cargo flash --chip RP2040
  monitor $@
}

################################################################################
# Release/Artifact Commands

function release:version {
  #@ Get current firmware version
  #@ Category: Release/Artifacts
  VERSION=$(grep -m1 '^version = ' firmware/Cargo.toml | cut -d'"' -f2)
  echo "$VERSION"
}

function release:build {
  #@ Build all release artifacts (elf, bin, uf2)
  #@ Category: Release/Artifacts
  echo "üèóÔ∏è Building release artifacts..."

  # Build both bootloader and firmware
  build:bootloader
  build --release

  # Get versions
  BOOTLOADER_VERSION=$(cargo pkgid -p bootloader | sed 's/.*#//')
  FIRMWARE_VERSION=$(release:version)

  # Create artifacts directory
  mkdir -p artifacts

  # Copy ELF files
  cp target/thumbv6m-none-eabi/release/bootloader artifacts/halpi2-rs-bootloader_${BOOTLOADER_VERSION}.elf
  cp target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf artifacts/halpi2-rs-firmware_${FIRMWARE_VERSION}.elf

  # Convert to other formats
  release:artifacts

  echo "‚úì Release artifacts created in artifacts/ directory"
}

function release:artifacts {
  #@ Convert existing ELF to bin/uf2 formats
  #@ Category: Release/Artifacts
  echo "üîÑ Converting artifacts..."

  if [ ! -d "artifacts" ]; then
    echo "Error: artifacts directory not found. Run 'release:build' first."
    exit 1
  fi

  # Convert each ELF to UF2 and BIN
  for elf in artifacts/*.elf; do
    if [ -f "$elf" ]; then
      base=$(basename "$elf" .elf)
      echo "Converting $base..."

      # Convert to UF2 (for bootsel mode flashing) using picotool
      picotool uf2 convert "$elf" "artifacts/${base}.uf2"

      # Convert to BIN (for some programming tools)
      if [[ "$base" == *"firmware"* ]]; then
        cargo objcopy --release -- -O binary "artifacts/${base}.bin"
      else
        cargo objcopy -p bootloader --release -- -O binary "artifacts/${base}.bin"
      fi

      echo "‚úì Created ${base}.uf2 and ${base}.bin"
    fi
  done
}

################################################################################
# Package Management Commands

function package:deb {
  #@ Build Debian package (native)
  #@ Category: Package Management
  echo "üèóÔ∏è Building Debian package..."

  # First, ensure we have release artifacts
  echo "üì¶ Building release artifacts first..."
  release:build

  # Now do the Debian packaging
  package:deb:only
}

function package:deb:only {
  #@ Build Debian package from existing artifacts (internal)
  #@ Category: Package Management
  echo "üì¶ Creating Debian package from artifacts..."

  # Set up environment
  dev:env

  export DEBEMAIL="info@hatlabs.fi"
  export DEBFULLNAME="Hat Labs CI"
  export FIRMWARE_VERSION=$(cat firmware/VERSION)
  DEB_VERSION=$(echo "$FIRMWARE_VERSION" | sed 's/-\([a-zA-Z]\)/~\1/g')

  envsubst < debian/install.in > debian/install

  # Create a new changelog entry
  dch --newversion "$DEB_VERSION" \
      --distribution stable \
      --force-distribution \
      "Automated release $FIRMWARE_VERSION. See GitHub for details."

  dpkg-buildpackage -us -uc -b

  echo "‚úÖ Debian package built successfully"
}

function package:deb:docker {
  #@ Build Debian package using Docker
  #@ Category: Package Management
  echo "üê≥ Building Debian package using Docker..."

  # Build release artifacts locally first (Docker container doesn't have Rust toolchain)
  echo "üì¶ Building release artifacts first..."
  release:build

  # Now use Docker container only for Debian packaging
  echo "üê≥ Running Debian packaging in Docker container..."
  export DIR_NAME=$(basename "$PWD")
  docker compose -f docker/docker-compose.debtools.yml run --rm debtools ./run package:deb:only

  echo "‚úÖ Docker-based Debian package built successfully"
}

function package:docker:build {
  #@ Build Docker tools image
  #@ Category: Package Management
  export DIR_NAME=$(basename "$PWD")
  docker compose -f docker/docker-compose.debtools.yml build debtools "$@"
}

################################################################################
# Testing/CI Commands

function test:prepare {
  #@ Copy artifacts to test directory
  #@ Category: Testing/CI
  build:bootloader
  build --release

  VERSION=$(release:version)
  BOOTLOADER_VERSION=$(cargo pkgid -p bootloader | sed 's/.*#//')

  cp target/thumbv6m-none-eabi/release/bootloader ../HALPI2-tests/tests/200_controller/files/halpi2-rs-bootloader_${BOOTLOADER_VERSION}.elf
  cp target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf ../HALPI2-tests/tests/200_controller/files/halpi2-rs-firmware_${VERSION}.elf
}

function ci:build {
  #@ Full CI build pipeline
  #@ Category: Testing/CI
  echo "üöÄ Running full CI build pipeline..."

  # Clean start
  clean

  # Build and check code quality
  check

  # Build packages (this will automatically build release artifacts first)
  package:deb:docker

  echo "‚úÖ CI build pipeline completed successfully"
}

function ci:check {
  #@ CI verification checks
  #@ Category: Testing/CI
  echo "üîç Running CI verification checks..."

  check
  build --release
  build:bootloader

  echo "‚úÖ CI checks passed"
}

################################################################################
# Development Utilities Commands

function dev:env {
  #@ Show/check development environment
  #@ Category: Development Utilities
  echo "üóùÔ∏è Setting environment from .env and .env.defaults"
  # Go through the files and export all variables not already present in
  # the environment. First file has precedence!
  if [ -f .env ]; then
    _export_unset .env
  else
    # Make sure a .env file exists, otherwise docker-compose will complain
    cp .env.defaults .env
  fi
  if [ -f .env.defaults ]; then
    _export_unset .env.defaults
  fi
}

function dev:clean:all {
  #@ Deep clean (cargo + artifacts + packages)
  #@ Category: Development Utilities
  echo "üßπ Performing deep clean..."

  # Clean cargo artifacts
  clean

  # Clean Debian packages
  rm -f ../*.deb ../*.buildinfo ../*.changes

  # Clean Docker containers and images
  export DIR_NAME=$(basename "$PWD")
  docker compose -f docker/docker-compose.debtools.yml down --rmi all --volumes || true

  echo "‚úÖ Deep clean completed"
}

function dev:version:bump {
  #@ Bump to specific version (e.g. 3.2.0)
  #@ Usage: dev:version:bump <version>
  #@ Category: Development Utilities
  local new_version="${1:-}"

  if [ -z "$new_version" ]; then
    echo "Error: Version required. Usage: dev:version:bump <new_version>"
    echo "Current version: $(release:version)"
    echo "Example: ./run dev:version:bump 3.2.0"
    exit 1
  fi

  echo "üîñ Bumping version from $(release:version) to $new_version..."
  bump2version --new-version "$new_version" patch
  echo "‚úì Version bumped to $(release:version)"
}

function dev:version:dry-run {
  #@ Preview version change without applying
  #@ Usage: dev:version:dry-run <version>
  #@ Category: Development Utilities
  local new_version="${1:-}"

  if [ -z "$new_version" ]; then
    echo "Error: Version required. Usage: dev:version:dry-run <new_version>"
    echo "Current version: $(release:version)"
    echo "Example: ./run dev:version:dry-run 3.2.0"
    exit 1
  fi

  echo "Current version: $(release:version)"
  echo "Preview of changes for version $new_version:"
  bump2version --new-version "$new_version" patch --dry-run --verbose
}

function dev:version:show {
  #@ Show current version
  #@ Category: Development Utilities
  release:version
}

################################################################################
# Project-specific commands end.

# Set up the environment.
# (Check the notes at the end when changing this.)

set -o nounset
set -o pipefail
set -o errexit

# Enable this to echo commands as they are executed.
#set -o xtrace

# Change the current directory to the project root.
PROJECT_ROOT=${0%/*}
if [[ $0 != $PROJECT_ROOT && $PROJECT_ROOT != "" ]]; then
  cd "$PROJECT_ROOT"
fi
readonly PROJECT_ROOT=$(pwd)

# Store the absolute path to this script (useful for recursion).
readonly SCRIPT="$PROJECT_ROOT/$(basename "$0")"

################################################################################
# Meta-commands and utilities follow.

function help {
  #@ Show help for all available commands (auto-generated)
  #@ Category: Meta
  printf "%s <command> [args]\n\n" "${0}"

  # Extract help information from function comments
  # This automatically generates help from #@ comments in functions
  local -A categories
  local -A descriptions
  local -A usages

  # Parse all functions and their help comments
  while IFS= read -r line; do
    if [[ "$line" =~ ^function[[:space:]]+([^[:space:]{}]+) ]]; then
      current_func="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^[[:space:]]*#@[[:space:]]*Category:[[:space:]]*(.+) ]]; then
      categories["$current_func"]="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^[[:space:]]*#@[[:space:]]*Usage:[[:space:]]*(.+) ]]; then
      usages["$current_func"]="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ ^[[:space:]]*#@[[:space:]]*(.+) ]] && [[ -z "${descriptions[$current_func]:-}" ]]; then
      descriptions["$current_func"]="${BASH_REMATCH[1]}"
    fi
  done < "$0"

  # Group functions by category and display
  local -A category_funcs
  for func in "${!categories[@]}"; do
    local cat="${categories[$func]}"
    category_funcs["$cat"]+="$func "
  done

  # Display in order of preference
  local ordered_categories=("Core Development" "Hardware Interaction" "Release/Artifacts" "Package Management" "Testing/CI" "Development Utilities" "Meta")

  for category in "${ordered_categories[@]}"; do
    if [[ -n "${category_funcs[$category]:-}" ]]; then
      echo "${category} Commands:"
      for func in ${category_funcs[$category]}; do
        local usage="${usages[$func]:-$func}"
        local desc="${descriptions[$func]:-No description}"
        printf "  %-30s %s\n" "$usage" "$desc"
      done
      echo ""
    fi
  done

  # Handle uncategorized functions
  for func in "${!descriptions[@]}"; do
    if [[ -z "${categories[$func]:-}" ]]; then
      local usage="${usages[$func]:-$func}"
      local desc="${descriptions[$func]}"
      printf "  %-30s %s\n" "$usage" "$desc"
    fi
  done
}

once_hash_array=()
function _once {
  # Run a command only once during the execution of this script, even if it's
  # called multiple times.
  #
  # Usage:
  #   _once <command> [argument ...]
  #
  # Example:
  #   _once echo "Hello"
  #   _once echo "Hello"  # won't be executed

  local command="$*"
  local hash=$(echo "$command" | shasum | cut -d' ' -f1)
  if [[ ! " ${once_hash_array[@]} " =~ " ${hash} " ]]; then
    once_hash_array+=("$hash")
    eval "$command"
  fi
}

function _export_unset {
  local file="$1"

  # Need to use a temp file to avoid a subshell
  local tmpfile=$(mktemp)
  grep -v '^#' $file >$tmpfile

  while read -r line; do
    if [[ ! "$line" =~ ^[[:space:]]*$ ]]; then
      varname=$(echo "$line" | cut -d= -f1)
      if [[ -z "${!varname:-}" ]]; then
        eval $line
        export $varname
      fi
    fi
  done <$tmpfile
  rm $tmpfile
}

# Dispatch to command. A simpler version would be just "$@" (with the quotes!).

TIMEFORMAT=$'\nTask completed in %3lR'
time "${@:-help}"

# Some dev notes for this script.
#
# The commands *require*:
#
# * The current working directory is the project root.
# * The shell options and globals are set as they are.
#
# Inspired by the following:
#  - https://death.andgravity.com/run-sh
#  - http://www.oilshell.org/blog/2020/02/good-parts-sketch.html
#  - https://www.youtube.com/watch?v=SdmYd5hJISM&t=7s
