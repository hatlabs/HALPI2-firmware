name: Build and Draft Release

on:
  push:
    branches: [main]

permissions:
  contents: write

jobs:
  build-firmware:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        fetch-tags: true

    - name: Read version
      id: version
      run: |
        VERSION=$(cat firmware/VERSION)
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Check if release exists
      id: check_release
      run: |
        if gh release view "v${{ steps.version.outputs.version }}" &>/dev/null; then
          IS_DRAFT=$(gh release view "v${{ steps.version.outputs.version }}" --json isDraft --jq '.isDraft')
          if [ "$IS_DRAFT" = "true" ]; then
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "delete_existing=true" >> $GITHUB_OUTPUT
            echo "Existing draft release found - will delete and recreate"
          else
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "delete_existing=false" >> $GITHUB_OUTPUT
            echo "Published release v${{ steps.version.outputs.version }} already exists - skipping"
          fi
        else
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "delete_existing=false" >> $GITHUB_OUTPUT
          echo "No existing release found"
        fi
      env:
        GH_TOKEN: ${{ github.token }}

    - name: Delete existing draft release
      if: steps.check_release.outputs.delete_existing == 'true'
      run: |
        echo "Deleting existing draft release v${{ steps.version.outputs.version }}"
        gh release delete "v${{ steps.version.outputs.version }}" --yes
      env:
        GH_TOKEN: ${{ github.token }}

    - name: Setup Rust
      if: steps.check_release.outputs.skip == 'false'
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: thumbv6m-none-eabi

    - name: Cache cargo registry
      if: steps.check_release.outputs.skip == 'false'
      uses: actions/cache@v4
      with:
        path: ~/.cargo/registry
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

    - name: Cache cargo index
      if: steps.check_release.outputs.skip == 'false'
      uses: actions/cache@v4
      with:
        path: ~/.cargo/git
        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

    - name: Cache target directory
      if: steps.check_release.outputs.skip == 'false'
      uses: actions/cache@v4
      with:
        path: target
        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('**/Cargo.lock') }}

    - name: Install format conversion tools
      if: steps.check_release.outputs.skip == 'false'
      run: |
        # Install arm-none-eabi-objcopy for BIN conversion
        sudo apt-get update
        sudo apt-get install -y gcc-arm-none-eabi dpkg-dev libudev1 libudev-dev

        # Install picotool pre-built binary (much faster than building from source)
        # Install libusb-1.0 dependency first
        sudo apt-get install -y libusb-1.0-0
        wget -q "https://github.com/raspberrypi/pico-sdk-tools/releases/download/v2.2.0-1/picotool-2.2.0-a4-x86_64-lin.tar.gz"
        tar -xzf "picotool-2.2.0-a4-x86_64-lin.tar.gz"
        sudo cp picotool/picotool /usr/local/bin/
        sudo chmod +x /usr/local/bin/picotool
        
        # Verify installation
        picotool version


    - name: Build bootloader
      if: steps.check_release.outputs.skip == 'false'
      run: |
        cargo build -p bootloader --release
        ls -la target/thumbv6m-none-eabi/release/

    - name: Build firmware
      if: steps.check_release.outputs.skip == 'false'
      run: |
        cargo build --release
        # Create .elf copies for tools that expect the extension
        cp target/thumbv6m-none-eabi/release/halpi2-rs-firmware target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf
        ls -la target/thumbv6m-none-eabi/release/

    - name: Convert to all formats
      if: steps.check_release.outputs.skip == 'false'
      run: |
        mkdir -p artifacts converted

        BOOTLOADER_VERSION=$(cargo pkgid -p bootloader | sed 's/.*#//')
        FIRMWARE_VERSION=$(cat firmware/VERSION)

        # Copy original ELF files
        cp target/thumbv6m-none-eabi/release/bootloader artifacts/halpi2-rs-bootloader_${BOOTLOADER_VERSION}.elf
        cp target/thumbv6m-none-eabi/release/halpi2-rs-firmware.elf artifacts/halpi2-rs-firmware_${FIRMWARE_VERSION}.elf

        # Convert each ELF to UF2 and BIN
        for elf in artifacts/*.elf; do
          if [ -f "$elf" ]; then
            base=$(basename "$elf" .elf)
            echo "Converting $base..."

            # Convert to UF2 (for bootsel mode flashing) using picotool
            picotool uf2 convert "$elf" "converted/${base}.uf2"

            # Convert to BIN (for some programming tools)
            arm-none-eabi-objcopy -O binary "$elf" "converted/${base}.bin"

            echo "âœ“ Created ${base}.uf2 and ${base}.bin"
          fi
        done

        # Copy converted files to artifacts
        cp converted/* artifacts/

        # Create build info
        cat > artifacts/build-info.txt << EOF
        Build Date: $(date -u)
        Git Commit: ${{ github.sha }}
        Git Tag: ${{ steps.version.outputs.version }}
        Workflow: ${{ github.run_id }}

        Files included:
        - halpi2-rs-bootloader_${BOOTLOADER_VERSION}.elf - Bootloader ELF (for debugger)
        - halpi2-rs-bootloader_${BOOTLOADER_VERSION}.uf2 - Bootloader UF2 (for bootsel mode)
        - halpi2-rs-bootloader_${BOOTLOADER_VERSION}.bin - Bootloader binary
        - halpi2-rs-firmware_${FIRMWARE_VERSION}.elf - Firmware ELF (for debugger)
        - halpi2-rs-firmware_${FIRMWARE_VERSION}.uf2 - Firmware UF2 (for bootsel mode)
        - halpi2-rs-firmware_${FIRMWARE_VERSION}.bin - Firmware binary
        EOF

        ls -la artifacts/

    - name: Prepare build environment for Debian packaging
      if: steps.check_release.outputs.skip == 'false'
      run: |
        # Install Debian packaging tools
        sudo apt-get update
        sudo apt-get install -y build-essential debhelper devscripts

        # Create a build directory with the firmware files
        mkdir -p build-area

    - name: Update debian/changelog with new version
      if: steps.check_release.outputs.skip == 'false'
      run: |
        # Update changelog with the new version
        export DEBEMAIL="info@hatlabs.fi"
        export DEBFULLNAME="Hat Labs CI"

        # Replace dashes with tildes for Debian versioning
        VERSION=$(cat firmware/VERSION)
        DEB_VERSION=$(echo "$VERSION" | sed 's/-\([a-zA-Z]\)/~\1/g')

        # Create a new changelog entry
        dch --newversion "$DEB_VERSION" \
            --distribution stable \
            --force-distribution \
            "Automated release $VERSION. See GitHub for details."

        echo "Updated changelog:"
        head -n 10 debian/changelog

    - name: Build Debian package using existing debian/ directory
      if: steps.check_release.outputs.skip == 'false'
      run: |
        # Set up environment for debian/install substitution
        export FIRMWARE_VERSION=$(cat firmware/VERSION)
        
        # Generate debian/install from template
        envsubst < debian/install.in > debian/install
        
        # Build the package using your existing debian/ setup
        dpkg-buildpackage -us -uc -b

        # Find the generated .deb file
        deb_file=$(ls ../*.deb | head -1)

        if [ -f "$deb_file" ]; then
          # Copy to artifacts directory
          cp "$deb_file" artifacts/
          echo "âœ“ Debian package created: $(basename "$deb_file")"

          # Show package info
          dpkg --info "$deb_file"
        else
          echo "âŒ Failed to find generated .deb file"
          ls -la ../
          exit 1
        fi

        echo "Final artifacts:"
        ls -la artifacts/

    - name: Generate release notes
      if: steps.check_release.outputs.skip == 'false'
      run: |
        VERSION=$(cat firmware/VERSION)

        # Get the latest published release tag for changelog
        LAST_TAG=$(gh release list --limit 100 --json tagName,isPrerelease,isDraft --jq '.[] | select(.isDraft == false and .isPrerelease == false) | .tagName' | head -n1)

        # Use the script to generate release notes (will fail workflow if script fails)
        bash .github/scripts/generate-release-notes.sh "$VERSION" "$LAST_TAG" "${{ github.repository }}" > release_notes.md

        # Verify the file was created and is not empty
        if [ ! -s release_notes.md ]; then
          echo "Error: Failed to generate release notes or file is empty" >&2
          exit 1
        fi

        echo "Generated release notes:"
        cat release_notes.md
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create draft release
      if: steps.check_release.outputs.skip == 'false'
      run: |
        VERSION=$(cat firmware/VERSION)

        # Create new draft release with generated notes
        gh release create v$VERSION \
          --draft \
          --title "HALPI2 Firmware v$VERSION" \
          --notes-file release_notes.md \
          artifacts/*
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create workflow summary
      if: steps.check_release.outputs.skip == 'false'
      run: |
        VERSION=$(cat firmware/VERSION)

        # Get the release URL dynamically after creation
        RELEASE_URL=$(gh release view v$VERSION --json url --jq '.url')

        echo "## âœ… Draft Release Created: v$VERSION" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“ Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "1. **Review Release Notes:** [v$VERSION Draft]($RELEASE_URL)" >> $GITHUB_STEP_SUMMARY
        echo "2. **Edit the \"What's New\" section** to highlight key changes" >> $GITHUB_STEP_SUMMARY
        echo "3. **Test artifacts** on hardware if needed" >> $GITHUB_STEP_SUMMARY
        echo "4. **Publish the release** when ready (triggers APT repo update)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“¦ Included Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- Firmware (ELF, UF2, BIN formats)" >> $GITHUB_STEP_SUMMARY
        echo "- Bootloader (ELF, UF2, BIN formats)" >> $GITHUB_STEP_SUMMARY
        echo "- Debian package" >> $GITHUB_STEP_SUMMARY
        echo "- Build metadata" >> $GITHUB_STEP_SUMMARY
      env:
        GH_TOKEN: ${{ github.token }}
